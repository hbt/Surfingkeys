#!/usr/bin/env node
/**
 * sk-cdp - Simplified CDP CLI wrapper for Surfingkeys debugging
 *
 * Wraps the CDP proxy to eliminate JSON escaping and provide a better DX
 *
 * Commands:
 *   eval       Evaluate JavaScript in a target
 *   targets    List all available CDP targets
 *   send       Send raw CDP method to a target
 *
 * Examples:
 *   sk-cdp eval "document.body.style.backgroundColor"
 *   sk-cdp eval --target options.html "document.querySelectorAll('input').length"
 *   sk-cdp targets
 *   sk-cdp targets --json
 *   sk-cdp send --target bg "Runtime.evaluate" '{"expression": "1+1"}'
 */

const http = require('http');
const WebSocket = require('ws');
const fs = require('fs');

// Configuration
const PROXY_PORT = 9623;
const PROXY_HOST = '127.0.0.1';
const CDP_PORT = 9222;
const CDP_HOST = '127.0.0.1';
const PROXY_LOG_FILE = '/tmp/dbg-proxy.log';

// Target shortcuts - common patterns for quick access
const TARGET_SHORTCUTS = {
    'bg': { type: 'service_worker', pattern: 'background.js' },
    'sw': { type: 'service_worker', pattern: 'background.js' },
    'background': { type: 'service_worker', pattern: 'background.js' },
    'options': { type: 'page', pattern: 'options.html' },
    'frontend': { type: 'iframe', pattern: 'frontend.html' },
    'popup': { type: 'page', pattern: 'popup.html' },
};

let messageId = 1;

const colors = {
    reset: '\x1b[0m',
    bright: '\x1b[1m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    cyan: '\x1b[36m',
    red: '\x1b[31m',
    gray: '\x1b[90m',
};

/**
 * Parse command line arguments
 */
function parseArgs() {
    const args = process.argv.slice(2);
    const parsed = {
        command: args[0],
        target: null,
        expression: null,
        watchErrors: false,
        json: false,
        raw: false,
        args: [],  // Remaining positional args after expression
    };

    let i = 1;
    let foundExpression = false;
    while (i < args.length) {
        if (args[i] === '--target' || args[i] === '-t') {
            parsed.target = args[++i];
        } else if (args[i] === '--watch-errors') {
            parsed.watchErrors = true;
        } else if (args[i] === '--json') {
            parsed.json = true;
        } else if (args[i] === '--raw') {
            parsed.raw = true;
        } else if (!args[i].startsWith('--')) {
            if (!foundExpression) {
                parsed.expression = args[i];
                foundExpression = true;
            } else {
                parsed.args.push(args[i]);
            }
        }
        i++;
    }

    return parsed;
}

/**
 * Fetch all CDP targets
 */
async function fetchTargets() {
    return new Promise((resolve, reject) => {
        http.get(`http://${CDP_HOST}:${CDP_PORT}/json`, (res) => {
            let body = '';
            res.on('data', chunk => (body += chunk));
            res.on('end', () => {
                try {
                    resolve(JSON.parse(body));
                } catch (e) {
                    reject(e);
                }
            });
        }).on('error', (err) => {
            if (err.code === 'ECONNREFUSED') {
                reject(new Error(`CDP not available at ${CDP_HOST}:${CDP_PORT}. Is Chrome running with --remote-debugging-port=${CDP_PORT}?`));
            } else {
                reject(err);
            }
        });
    });
}

/**
 * Find target by pattern or shortcut
 */
async function findTarget(pattern) {
    const targets = await fetchTargets();

    // Check for shortcut first
    if (pattern && TARGET_SHORTCUTS[pattern.toLowerCase()]) {
        const shortcut = TARGET_SHORTCUTS[pattern.toLowerCase()];
        const target = targets.find(t =>
            t.type === shortcut.type && t.url?.includes(shortcut.pattern)
        );
        if (target) return target;
        throw new Error(`Target shortcut '${pattern}' not found. Available shortcuts: ${Object.keys(TARGET_SHORTCUTS).join(', ')}`);
    }

    // No pattern - find first extension page or service worker
    if (!pattern) {
        // Prefer service worker (background)
        let target = targets.find(t =>
            t.type === 'service_worker' && t.url?.includes('chrome-extension')
        );
        if (!target) {
            // Fall back to extension page
            target = targets.find(t =>
                t.type === 'page' && t.url?.includes('chrome-extension')
            );
        }
        if (target) return target;
        throw new Error('No extension target found. Is the extension loaded?');
    }

    // Pattern matching - search all target types
    const target = targets.find(t => t.url?.includes(pattern));

    if (target) return target;

    // Helpful error with suggestions
    const extensionTargets = targets.filter(t => t.url?.includes('chrome-extension'));
    const suggestions = extensionTargets.slice(0, 3).map(t => `  - ${t.type}: ${t.url.split('/').pop()}`);

    let errorMsg = `Target not found matching: ${pattern}`;
    if (suggestions.length > 0) {
        errorMsg += `\n\nAvailable extension targets:\n${suggestions.join('\n')}`;
        errorMsg += `\n\nShortcuts: ${Object.keys(TARGET_SHORTCUTS).join(', ')}`;
    }
    throw new Error(errorMsg);
}

/**
 * Send command via proxy
 */
function sendViaProxy(targetId, method, params) {
    return new Promise((resolve, reject) => {
        const command = {
            targetId,
            method,
            params,
        };

        const data = JSON.stringify(command);
        const ws = new WebSocket(`ws://${PROXY_HOST}:${PROXY_PORT}`);

        const timeout = setTimeout(() => {
            ws.close();
            reject(new Error('Timeout waiting for response'));
        }, 5000);

        ws.on('open', () => {
            ws.send(data);
        });

        ws.on('message', (msg) => {
            clearTimeout(timeout);
            ws.close();

            try {
                const response = JSON.parse(msg);
                resolve(response);
            } catch (e) {
                reject(e);
            }
        });

        ws.on('error', (err) => {
            clearTimeout(timeout);
            reject(err);
        });
    });
}

/**
 * Get metadata about the target and page
 */
async function getMetadata(targetId) {
    const startTime = Date.now();

    try {
        // Get document and window info
        const docResponse = await sendViaProxy(
            targetId,
            'Runtime.evaluate',
            {
                expression: `
                    (function() {
                        return {
                            document: {
                                url: document.location.href,
                                title: document.title,
                                readyState: document.readyState
                            },
                            window: {
                                innerHeight: window.innerHeight,
                                innerWidth: window.innerWidth,
                                scrollX: window.scrollX,
                                scrollY: window.scrollY,
                                devicePixelRatio: window.devicePixelRatio
                            },
                            context: {
                                isIframe: window !== window.top,
                                hasShadowRoot: !!document.querySelector('[shadowroot]') ||
                                              Array.from(document.querySelectorAll('*')).some(el => el.shadowRoot)
                            }
                        };
                    })()
                `,
                returnByValue: true,
            }
        );

        // Try to get tab info from chrome.tabs API
        let tabInfo = null;
        try {
            const tabResponse = await sendViaProxy(
                targetId,
                'Runtime.evaluate',
                {
                    expression: `
                        (function() {
                            if (typeof chrome !== 'undefined' && chrome.tabs) {
                                return new Promise(resolve => {
                                    chrome.tabs.query({active: true, currentWindow: true}, tabs => {
                                        if (tabs && tabs[0]) {
                                            resolve({
                                                id: tabs[0].id,
                                                url: tabs[0].url,
                                                title: tabs[0].title,
                                                active: tabs[0].active,
                                                status: tabs[0].status,
                                                windowId: tabs[0].windowId,
                                                index: tabs[0].index
                                            });
                                        } else {
                                            resolve(null);
                                        }
                                    });
                                });
                            }
                            return null;
                        })()
                    `,
                    returnByValue: true,
                    awaitPromise: true,
                }
            );
            tabInfo = tabResponse.result?.result?.value;
        } catch (e) {
            // Tab API not available, that's ok
        }

        // Get element count with timing
        const elemCountStartTime = Date.now();
        const elemCountResponse = await sendViaProxy(
            targetId,
            'Runtime.evaluate',
            {
                expression: `document.querySelectorAll('*').length`,
                returnByValue: true,
            }
        );
        const elementCountTime = Date.now() - elemCountStartTime;
        const elementCount = elemCountResponse.result?.result?.value;

        const docInfo = docResponse.result?.result?.value;
        const duration = Date.now() - startTime;

        return {
            execution: {
                duration_ms: duration,
                timestamp: new Date().toISOString(),
            },
            tab: tabInfo,
            context: {
                type: docInfo?.context?.isIframe ? 'iframe' : (docInfo?.context?.hasShadowRoot ? 'shadow-root' : 'page'),
                isIframe: docInfo?.context?.isIframe,
                isShadowRoot: docInfo?.context?.hasShadowRoot,
                warnings: [],
            },
            document: {
                url: docInfo?.document?.url,
                title: docInfo?.document?.title,
                readyState: docInfo?.document?.readyState,
                elementCount,
                elementCountTime_ms: elementCountTime,
            },
            viewport: {
                innerHeight: docInfo?.window?.innerHeight,
                innerWidth: docInfo?.window?.innerWidth,
                scrollX: docInfo?.window?.scrollX,
                scrollY: docInfo?.window?.scrollY,
                devicePixelRatio: docInfo?.window?.devicePixelRatio,
            },
        };
    } catch (error) {
        return {
            execution: {
                duration_ms: Date.now() - startTime,
                timestamp: new Date().toISOString(),
            },
            error: error.message,
        };
    }
}

/**
 * Evaluate JavaScript expression on target
 */
async function evalExpression(targetId, expression) {
    const response = await sendViaProxy(
        targetId,
        'Runtime.evaluate',
        {
            expression,
            returnByValue: true,
            awaitPromise: true,
        }
    );

    return response;
}

/**
 * Format response for display
 */
function formatResponse(response, options = {}) {
    if (options.raw) {
        return JSON.stringify(response, null, 2);
    }

    if (options.json) {
        return JSON.stringify(response, null, 2);
    }

    // Pretty print
    let output = '';

    // Check for proxy-level errors
    if (response.error) {
        output += `${colors.red}‚ùå Error: ${response.error.message}${colors.reset}\n`;
        return output;
    }

    // Extract result
    const result = response.result?.result;

    if (!result) {
        output += `${colors.gray}(no result)${colors.reset}\n`;
        return output;
    }

    // Check for JavaScript exceptions
    if (response.result?.exceptionDetails) {
        const exc = response.result.exceptionDetails;
        output += `${colors.red}‚ùå Exception: ${result.description || exc.text}${colors.reset}\n`;
        return output;
    }

    // Format result value
    let resultOutput = '';
    if (result.type === 'string') {
        resultOutput = `${colors.green}"${result.value}"${colors.reset}`;
    } else if (result.type === 'number') {
        resultOutput = `${colors.cyan}${result.value}${colors.reset}`;
    } else if (result.type === 'boolean') {
        resultOutput = `${colors.yellow}${result.value}${colors.reset}`;
    } else if (result.type === 'object') {
        if (result.subtype === 'error') {
            resultOutput = `${colors.red}${result.description}${colors.reset}`;
        } else {
            resultOutput = `${colors.bright}${JSON.stringify(result.value, null, 2)}${colors.reset}`;
        }
    } else if (result.type === 'undefined') {
        resultOutput = `${colors.gray}undefined${colors.reset}`;
    } else {
        resultOutput = `${result.type}: ${JSON.stringify(result.value)}`;
    }

    output += resultOutput + '\n';

    // Show metadata summary if available
    if (response.metadata) {
        const before = response.metadata.before;
        const after = response.metadata.after;

        output += `\n${colors.gray}‚îÄ Metadata ‚îÄ${colors.reset}\n`;
        output += `${colors.gray}Duration: ${after.execution.duration_ms}ms${colors.reset}\n`;

        if (before.tab && after.tab) {
            // Compare tab info
            if (before.tab.active !== after.tab.active) {
                output += `${colors.yellow}‚ö†Ô∏è  Tab active status changed${colors.reset}\n`;
            }
            if (before.tab.url !== after.tab.url) {
                output += `${colors.yellow}‚ö†Ô∏è  Tab URL changed${colors.reset}\n`;
                output += `${colors.gray}  From: ${before.tab.url}${colors.reset}\n`;
                output += `${colors.gray}  To: ${after.tab.url}${colors.reset}\n`;
            }
            if (before.tab.title !== after.tab.title) {
                output += `${colors.yellow}‚ö†Ô∏è  Tab title changed${colors.reset}\n`;
            }
        }

        // Compare document state
        if (before.document && after.document) {
            if (before.document.readyState !== after.document.readyState) {
                output += `${colors.cyan}Document ready state: ${before.document.readyState} ‚Üí ${after.document.readyState}${colors.reset}\n`;
            }
            if (before.document.elementCount !== after.document.elementCount) {
                const diff = after.document.elementCount - before.document.elementCount;
                const sign = diff > 0 ? '+' : '';
                output += `${colors.cyan}Elements: ${before.document.elementCount} ‚Üí ${after.document.elementCount} (${sign}${diff})${colors.reset}\n`;
            }
        }

        // Show context info
        if (after.context) {
            output += `${colors.gray}Context: ${after.context.type}${colors.reset}`;
            if (after.context.isIframe) output += ` ${colors.yellow}[iframe]${colors.reset}`;
            if (after.context.isShadowRoot) output += ` ${colors.yellow}[shadow-dom]${colors.reset}`;
            output += '\n';
        }

        // Show console capture info
        if (response.metadata?.console?.logFile) {
            output += `${colors.gray}Console log: ${response.metadata.console.logFile}${colors.reset}\n`;
        }

        output += `${colors.gray}Timestamp: ${after.execution.timestamp}${colors.reset}\n`;
    }

    return output;
}

/**
 * Read stdin if available
 */
function readStdin() {
    return new Promise((resolve) => {
        if (process.stdin.isTTY) {
            resolve(null);
            return;
        }

        let data = '';
        process.stdin.setEncoding('utf8');

        process.stdin.on('readable', () => {
            let chunk;
            while ((chunk = process.stdin.read()) !== null) {
                data += chunk;
            }
        });

        process.stdin.on('end', () => {
            resolve(data.trim());
        });
    });
}

/**
 * Show help message
 */
function showHelp() {
    console.log(`${colors.bright}sk-cdp${colors.reset} - CDP debugging CLI for Surfingkeys

${colors.yellow}Commands:${colors.reset}
  ${colors.green}eval${colors.reset}       Evaluate JavaScript expression in a target
  ${colors.green}targets${colors.reset}    List all available CDP targets
  ${colors.green}send${colors.reset}       Send raw CDP method to a target

${colors.yellow}Usage:${colors.reset}
  sk-cdp eval [OPTIONS] "expression"
  sk-cdp eval [OPTIONS] <<'CODE'
    multiline code here
  CODE
  sk-cdp targets [--json]
  sk-cdp send --target TARGET METHOD [PARAMS_JSON]

${colors.yellow}Options:${colors.reset}
  --target PATTERN    Target to debug (use shortcut or URL pattern)
  --json              Output raw JSON (machine-readable)
  --raw               Show raw CDP response object
  --watch-errors      Exit with error code on exceptions

${colors.yellow}Target Shortcuts:${colors.reset}
  ${colors.cyan}bg, sw, background${colors.reset}   Service worker (background.js)
  ${colors.cyan}options${colors.reset}              Options page
  ${colors.cyan}frontend${colors.reset}             Frontend iframe
  ${colors.cyan}popup${colors.reset}                Popup page

${colors.yellow}Examples:${colors.reset}
  ${colors.gray}# List all targets${colors.reset}
  sk-cdp targets

  ${colors.gray}# Evaluate in service worker (background)${colors.reset}
  sk-cdp eval --target bg "chrome.runtime.id"

  ${colors.gray}# Evaluate in options page${colors.reset}
  sk-cdp eval --target options "document.title"

  ${colors.gray}# Quick check on any google.com tab${colors.reset}
  sk-cdp eval --target google.com "document.title"

  ${colors.gray}# Send raw CDP method${colors.reset}
  sk-cdp send --target bg "Runtime.evaluate" '{"expression":"1+1","returnByValue":true}'

  ${colors.gray}# Multiline code via heredoc${colors.reset}
  sk-cdp eval --target bg <<'CODE'
    new Promise(r => chrome.storage.local.get(null, r))
  CODE

${colors.yellow}Notes:${colors.reset}
  - Requires CDP proxy: ${colors.cyan}./bin/dbg proxy-start${colors.reset}
  - Console logs captured in: ${colors.cyan}/tmp/dbg-proxy.jsonl${colors.reset}
  - JSON output (--json) is best for scripting/agents
`);
}

/**
 * List all CDP targets
 */
async function listTargets(opts) {
    const targets = await fetchTargets();

    // Group by type
    const grouped = {};
    for (const t of targets) {
        if (!grouped[t.type]) grouped[t.type] = [];
        grouped[t.type].push(t);
    }

    if (opts.json) {
        // Machine-readable output
        const output = {
            targets: targets.map(t => ({
                id: t.id,
                type: t.type,
                url: t.url,
                title: t.title,
                webSocketDebuggerUrl: t.webSocketDebuggerUrl,
            })),
            shortcuts: TARGET_SHORTCUTS,
            summary: {
                total: targets.length,
                byType: Object.fromEntries(
                    Object.entries(grouped).map(([k, v]) => [k, v.length])
                ),
            },
        };
        console.log(JSON.stringify(output, null, 2));
        return;
    }

    // Human-readable output
    console.log(`${colors.bright}CDP Targets${colors.reset} (${targets.length} total)\n`);

    const typeOrder = ['service_worker', 'page', 'iframe', 'other'];
    const typeLabels = {
        service_worker: 'üîß Service Workers',
        page: 'üìÑ Pages',
        iframe: 'üñºÔ∏è  Iframes',
        other: '‚ùì Other',
    };

    for (const type of typeOrder) {
        const items = grouped[type] || [];
        if (items.length === 0) continue;

        console.log(`${colors.yellow}${typeLabels[type] || type}${colors.reset} (${items.length})`);

        for (const t of items.slice(0, 10)) {
            const urlShort = t.url?.length > 80 ? t.url.substring(0, 77) + '...' : t.url;
            const isExtension = t.url?.includes('chrome-extension');

            let line = `  ${colors.gray}${t.id.substring(0, 8)}${colors.reset}`;
            line += isExtension ? ` ${colors.green}${urlShort}${colors.reset}` : ` ${urlShort}`;

            // Show matching shortcut
            for (const [shortcut, config] of Object.entries(TARGET_SHORTCUTS)) {
                if (t.type === config.type && t.url?.includes(config.pattern)) {
                    line += ` ${colors.cyan}[${shortcut}]${colors.reset}`;
                    break;
                }
            }

            console.log(line);
        }

        if (items.length > 10) {
            console.log(`  ${colors.gray}... and ${items.length - 10} more${colors.reset}`);
        }
        console.log();
    }

    console.log(`${colors.gray}Use --json for machine-readable output${colors.reset}`);
}

/**
 * Send raw CDP method
 */
async function sendRawMethod(opts) {
    if (!opts.target) {
        throw new Error('--target is required for send command');
    }

    // Method is in expression, params JSON is in args[0]
    const method = opts.expression;
    const paramsJson = (opts.args && opts.args[0]) || '{}';

    if (!method) {
        throw new Error('Method name is required. Usage: sk-cdp send --target bg "Runtime.evaluate" \'{"expression":"1+1"}\'');
    }

    let params;
    try {
        params = JSON.parse(paramsJson);
    } catch (e) {
        throw new Error(`Invalid JSON params: ${e.message}`);
    }

    const target = await findTarget(opts.target);
    const response = await sendViaProxy(target.id, method, params);

    if (opts.json) {
        console.log(JSON.stringify(response, null, 2));
    } else {
        console.log(formatResponse(response, opts));
    }
}

/**
 * Main CLI handler
 */
async function main() {
    const args = process.argv.slice(2);

    // Handle help flags before parsing
    if (args.length === 0 || args[0] === '--help' || args[0] === '-h' || args[0] === 'help') {
        showHelp();
        process.exit(0);
    }

    const opts = parseArgs();

    try {
        switch (opts.command) {
            case 'targets':
            case 'list':
                await listTargets(opts);
                break;

            case 'send':
                await sendRawMethod(opts);
                break;

            case 'eval':
                await runEval(opts);
                break;

            default:
                console.error(`${colors.red}Unknown command: ${opts.command}${colors.reset}`);
                console.error(`\nAvailable commands: eval, targets, send`);
                console.error(`Run ${colors.cyan}sk-cdp --help${colors.reset} for usage`);
                process.exit(1);
        }
    } catch (error) {
        console.error(`${colors.red}‚ùå ${error.message}${colors.reset}`);
        process.exit(1);
    }
}

/**
 * Run eval command
 */
async function runEval(opts) {
    // Get expression from args or stdin
    let expression = opts.expression;

    if (!expression) {
        expression = await readStdin();
    }

    if (!expression) {
        console.error(`${colors.red}No expression provided${colors.reset}`);
        console.error(`\nUsage: sk-cdp eval [--target TARGET] "expression"`);
        process.exit(1);
    }

    // Find target
    const target = await findTarget(opts.target);

    // Capture metadata before
    const metadataBefore = await getMetadata(target.id);

    // Evaluate
    const response = await evalExpression(target.id, expression);

    // Capture metadata after
    const metadataAfter = await getMetadata(target.id);

    // Combine response with metadata
    const fullResponse = {
        ...response,
        target: {
            id: target.id,
            type: target.type,
            url: target.url,
        },
        metadata: {
            before: metadataBefore,
            after: metadataAfter,
            console: {
                logFile: fs.existsSync(PROXY_LOG_FILE) ? PROXY_LOG_FILE : null,
                note: 'Captured by proxy (bin/dbg proxy-start)',
            },
        },
    };

    // Format and display
    const formatted = formatResponse(fullResponse, {
        json: opts.json,
        raw: opts.raw,
    });

    process.stdout.write(formatted);

    // Check for errors if watching
    if (opts.watchErrors && response.result?.exceptionDetails) {
        console.error(
            `${colors.red}‚ö†Ô∏è  Exception: ${response.result.exceptionDetails.text}${colors.reset}`
        );
        process.exit(1);
    }
}

main();
