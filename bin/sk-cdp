#!/usr/bin/env node
/**
 * sk-cdp - Simplified CDP CLI wrapper for Surfingkeys debugging
 *
 * Wraps the CDP proxy to eliminate JSON escaping and provide a better DX
 *
 * Examples:
 *   sk-cdp eval "document.body.style.backgroundColor"
 *   sk-cdp eval --target options.html "document.querySelectorAll('input').length"
 *   sk-cdp eval --target options.html <<'CODE'
 *     const inputs = document.querySelectorAll('input');
 *     return Array.from(inputs).map(i => i.value);
 *   CODE
 */

const http = require('http');
const WebSocket = require('ws');
const fs = require('fs');

// Configuration
const PROXY_PORT = 9623;
const PROXY_HOST = '127.0.0.1';
const CDP_PORT = 9222;
const CDP_HOST = '127.0.0.1';
const PROXY_LOG_FILE = '/tmp/dbg-proxy.log';

let messageId = 1;

const colors = {
    reset: '\x1b[0m',
    bright: '\x1b[1m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    cyan: '\x1b[36m',
    red: '\x1b[31m',
    gray: '\x1b[90m',
};

/**
 * Parse command line arguments
 */
function parseArgs() {
    const args = process.argv.slice(2);
    const parsed = {
        command: args[0],
        target: null,
        expression: null,
        watchErrors: false,
        json: false,
        raw: false,
        args: [],
    };

    let i = 1;
    while (i < args.length) {
        if (args[i] === '--target') {
            parsed.target = args[++i];
        } else if (args[i] === '--watch-errors') {
            parsed.watchErrors = true;
        } else if (args[i] === '--json') {
            parsed.json = true;
        } else if (args[i] === '--raw') {
            parsed.raw = true;
        } else if (!args[i].startsWith('--')) {
            parsed.expression = args[i];
            break;
        }
        i++;
    }

    return parsed;
}

/**
 * Find target by URL pattern
 */
async function findTarget(pattern) {
    return new Promise((resolve, reject) => {
        http.get(`http://${CDP_HOST}:${CDP_PORT}/json`, (res) => {
            let body = '';
            res.on('data', chunk => (body += chunk));
            res.on('end', () => {
                try {
                    const targets = JSON.parse(body);
                    let target;

                    if (!pattern) {
                        // Find first extension page
                        target = targets.find(t =>
                            t.type === 'page' && t.url?.includes('chrome-extension')
                        );
                    } else {
                        // Find by pattern
                        target = targets.find(t =>
                            t.type === 'page' && t.url?.includes(pattern)
                        );
                    }

                    if (target) {
                        resolve(target);
                    } else {
                        reject(new Error(`Target not found matching: ${pattern || 'extension'}`));
                    }
                } catch (e) {
                    reject(e);
                }
            });
        }).on('error', reject);
    });
}

/**
 * Send command via proxy
 */
function sendViaProxy(targetId, method, params) {
    return new Promise((resolve, reject) => {
        const command = {
            targetId,
            method,
            params,
        };

        const data = JSON.stringify(command);
        const ws = new WebSocket(`ws://${PROXY_HOST}:${PROXY_PORT}`);

        const timeout = setTimeout(() => {
            ws.close();
            reject(new Error('Timeout waiting for response'));
        }, 5000);

        ws.on('open', () => {
            ws.send(data);
        });

        ws.on('message', (msg) => {
            clearTimeout(timeout);
            ws.close();

            try {
                const response = JSON.parse(msg);
                resolve(response);
            } catch (e) {
                reject(e);
            }
        });

        ws.on('error', (err) => {
            clearTimeout(timeout);
            reject(err);
        });
    });
}

/**
 * Get metadata about the target and page
 */
async function getMetadata(targetId) {
    const startTime = Date.now();

    try {
        // Get document and window info
        const docResponse = await sendViaProxy(
            targetId,
            'Runtime.evaluate',
            {
                expression: `
                    (function() {
                        return {
                            document: {
                                url: document.location.href,
                                title: document.title,
                                readyState: document.readyState
                            },
                            window: {
                                innerHeight: window.innerHeight,
                                innerWidth: window.innerWidth,
                                scrollX: window.scrollX,
                                scrollY: window.scrollY,
                                devicePixelRatio: window.devicePixelRatio
                            },
                            context: {
                                isIframe: window !== window.top,
                                hasShadowRoot: !!document.querySelector('[shadowroot]') ||
                                              Array.from(document.querySelectorAll('*')).some(el => el.shadowRoot)
                            }
                        };
                    })()
                `,
                returnByValue: true,
            }
        );

        // Try to get tab info from chrome.tabs API
        let tabInfo = null;
        try {
            const tabResponse = await sendViaProxy(
                targetId,
                'Runtime.evaluate',
                {
                    expression: `
                        (function() {
                            if (typeof chrome !== 'undefined' && chrome.tabs) {
                                return new Promise(resolve => {
                                    chrome.tabs.query({active: true, currentWindow: true}, tabs => {
                                        if (tabs && tabs[0]) {
                                            resolve({
                                                id: tabs[0].id,
                                                url: tabs[0].url,
                                                title: tabs[0].title,
                                                active: tabs[0].active,
                                                status: tabs[0].status,
                                                windowId: tabs[0].windowId,
                                                index: tabs[0].index
                                            });
                                        } else {
                                            resolve(null);
                                        }
                                    });
                                });
                            }
                            return null;
                        })()
                    `,
                    returnByValue: true,
                    awaitPromise: true,
                }
            );
            tabInfo = tabResponse.result?.result?.value;
        } catch (e) {
            // Tab API not available, that's ok
        }

        // Get element count with timing
        const elemCountStartTime = Date.now();
        const elemCountResponse = await sendViaProxy(
            targetId,
            'Runtime.evaluate',
            {
                expression: `document.querySelectorAll('*').length`,
                returnByValue: true,
            }
        );
        const elementCountTime = Date.now() - elemCountStartTime;
        const elementCount = elemCountResponse.result?.result?.value;

        const docInfo = docResponse.result?.result?.value;
        const duration = Date.now() - startTime;

        return {
            execution: {
                duration_ms: duration,
                timestamp: new Date().toISOString(),
            },
            tab: tabInfo,
            context: {
                type: docInfo?.context?.isIframe ? 'iframe' : (docInfo?.context?.hasShadowRoot ? 'shadow-root' : 'page'),
                isIframe: docInfo?.context?.isIframe,
                isShadowRoot: docInfo?.context?.hasShadowRoot,
                warnings: [],
            },
            document: {
                url: docInfo?.document?.url,
                title: docInfo?.document?.title,
                readyState: docInfo?.document?.readyState,
                elementCount,
                elementCountTime_ms: elementCountTime,
            },
            viewport: {
                innerHeight: docInfo?.window?.innerHeight,
                innerWidth: docInfo?.window?.innerWidth,
                scrollX: docInfo?.window?.scrollX,
                scrollY: docInfo?.window?.scrollY,
                devicePixelRatio: docInfo?.window?.devicePixelRatio,
            },
        };
    } catch (error) {
        return {
            execution: {
                duration_ms: Date.now() - startTime,
                timestamp: new Date().toISOString(),
            },
            error: error.message,
        };
    }
}

/**
 * Evaluate JavaScript expression on target
 */
async function evalExpression(targetId, expression) {
    const response = await sendViaProxy(
        targetId,
        'Runtime.evaluate',
        {
            expression,
            returnByValue: true,
            awaitPromise: true,
        }
    );

    return response;
}

/**
 * Format response for display
 */
function formatResponse(response, options = {}) {
    if (options.raw) {
        return JSON.stringify(response, null, 2);
    }

    if (options.json) {
        return JSON.stringify(response, null, 2);
    }

    // Pretty print
    let output = '';

    // Check for proxy-level errors
    if (response.error) {
        output += `${colors.red}❌ Error: ${response.error.message}${colors.reset}\n`;
        return output;
    }

    // Extract result
    const result = response.result?.result;

    if (!result) {
        output += `${colors.gray}(no result)${colors.reset}\n`;
        return output;
    }

    // Check for JavaScript exceptions
    if (response.result?.exceptionDetails) {
        const exc = response.result.exceptionDetails;
        output += `${colors.red}❌ Exception: ${result.description || exc.text}${colors.reset}\n`;
        return output;
    }

    // Format result value
    let resultOutput = '';
    if (result.type === 'string') {
        resultOutput = `${colors.green}"${result.value}"${colors.reset}`;
    } else if (result.type === 'number') {
        resultOutput = `${colors.cyan}${result.value}${colors.reset}`;
    } else if (result.type === 'boolean') {
        resultOutput = `${colors.yellow}${result.value}${colors.reset}`;
    } else if (result.type === 'object') {
        if (result.subtype === 'error') {
            resultOutput = `${colors.red}${result.description}${colors.reset}`;
        } else {
            resultOutput = `${colors.bright}${JSON.stringify(result.value, null, 2)}${colors.reset}`;
        }
    } else if (result.type === 'undefined') {
        resultOutput = `${colors.gray}undefined${colors.reset}`;
    } else {
        resultOutput = `${result.type}: ${JSON.stringify(result.value)}`;
    }

    output += resultOutput + '\n';

    // Show metadata summary if available
    if (response.metadata) {
        const before = response.metadata.before;
        const after = response.metadata.after;

        output += `\n${colors.gray}─ Metadata ─${colors.reset}\n`;
        output += `${colors.gray}Duration: ${after.execution.duration_ms}ms${colors.reset}\n`;

        if (before.tab && after.tab) {
            // Compare tab info
            if (before.tab.active !== after.tab.active) {
                output += `${colors.yellow}⚠️  Tab active status changed${colors.reset}\n`;
            }
            if (before.tab.url !== after.tab.url) {
                output += `${colors.yellow}⚠️  Tab URL changed${colors.reset}\n`;
                output += `${colors.gray}  From: ${before.tab.url}${colors.reset}\n`;
                output += `${colors.gray}  To: ${after.tab.url}${colors.reset}\n`;
            }
            if (before.tab.title !== after.tab.title) {
                output += `${colors.yellow}⚠️  Tab title changed${colors.reset}\n`;
            }
        }

        // Compare document state
        if (before.document && after.document) {
            if (before.document.readyState !== after.document.readyState) {
                output += `${colors.cyan}Document ready state: ${before.document.readyState} → ${after.document.readyState}${colors.reset}\n`;
            }
            if (before.document.elementCount !== after.document.elementCount) {
                const diff = after.document.elementCount - before.document.elementCount;
                const sign = diff > 0 ? '+' : '';
                output += `${colors.cyan}Elements: ${before.document.elementCount} → ${after.document.elementCount} (${sign}${diff})${colors.reset}\n`;
            }
        }

        // Show context info
        if (after.context) {
            output += `${colors.gray}Context: ${after.context.type}${colors.reset}`;
            if (after.context.isIframe) output += ` ${colors.yellow}[iframe]${colors.reset}`;
            if (after.context.isShadowRoot) output += ` ${colors.yellow}[shadow-dom]${colors.reset}`;
            output += '\n';
        }

        // Show console capture info
        if (response.metadata?.console?.logFile) {
            output += `${colors.gray}Console log: ${response.metadata.console.logFile}${colors.reset}\n`;
        }

        output += `${colors.gray}Timestamp: ${after.execution.timestamp}${colors.reset}\n`;
    }

    return output;
}

/**
 * Read stdin if available
 */
function readStdin() {
    return new Promise((resolve) => {
        if (process.stdin.isTTY) {
            resolve(null);
            return;
        }

        let data = '';
        process.stdin.setEncoding('utf8');

        process.stdin.on('readable', () => {
            let chunk;
            while ((chunk = process.stdin.read()) !== null) {
                data += chunk;
            }
        });

        process.stdin.on('end', () => {
            resolve(data.trim());
        });
    });
}

/**
 * Main CLI handler
 */
async function main() {
    const opts = parseArgs();

    if (!opts.command) {
        console.log(`${colors.bright}sk-cdp${colors.reset} - CDP debugging CLI

${colors.yellow}Usage:${colors.reset}
  sk-cdp eval [OPTIONS] "expression"
  sk-cdp eval [OPTIONS] <<'CODE'
    multiline code here
  CODE

${colors.yellow}Options:${colors.reset}
  --target PATTERN    Target to debug (default: first extension page)
  --watch-errors      Log any console errors
  --json              Output raw JSON
  --raw               Show raw response object

${colors.yellow}Examples:${colors.reset}
  sk-cdp eval "document.body.style.backgroundColor"
  sk-cdp eval --target options.html "document.querySelectorAll('input').length"
  sk-cdp eval --target options.html <<'CODE'
    const inputs = document.querySelectorAll('input');
    return Array.from(inputs).map(i => i.value);
  CODE
`);
        process.exit(0);
    }

    if (opts.command !== 'eval') {
        console.error(`${colors.red}Unknown command: ${opts.command}${colors.reset}`);
        process.exit(1);
    }

    try {
        // Get expression from args or stdin
        let expression = opts.expression;

        if (!expression) {
            expression = await readStdin();
        }

        if (!expression) {
            console.error(`${colors.red}No expression provided${colors.reset}`);
            process.exit(1);
        }

        // Find target
        const target = await findTarget(opts.target);

        if (!target) {
            throw new Error('No matching target found');
        }

        // Capture metadata before
        const metadataBefore = await getMetadata(target.id);

        // Evaluate
        const response = await evalExpression(target.id, expression);

        // Capture metadata after
        const metadataAfter = await getMetadata(target.id);

        // Combine response with metadata
        const fullResponse = {
            ...response,
            metadata: {
                before: metadataBefore,
                after: metadataAfter,
                console: {
                    logFile: fs.existsSync(PROXY_LOG_FILE) ? PROXY_LOG_FILE : null,
                    note: 'Captured by proxy (bin/dbg proxy-start)',
                },
            },
        };

        // Format and display
        const formatted = formatResponse(fullResponse, {
            json: opts.json,
            raw: opts.raw,
        });

        process.stdout.write(formatted);

        // Check for errors if watching
        if (opts.watchErrors && response.result?.exceptionDetails) {
            console.error(
                `${colors.red}⚠️  Exception: ${response.result.exceptionDetails.text}${colors.reset}`
            );
            process.exit(1);
        }

        process.exit(0);
    } catch (error) {
        console.error(`${colors.red}❌ ${error.message}${colors.reset}`);
        process.exit(1);
    }
}

main();
